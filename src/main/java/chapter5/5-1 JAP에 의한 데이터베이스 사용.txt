        스프링 프레임워크의 지속성 접근법

MVC 아키텍쳐에선 데이터는 'Model' 로 정의한다.
스프링 부트에선 스프링 프레임워크의 웹 애플리케이션 프레임워크인 '스프링 MVC' 가 MVC 아키텍쳐의 핵심이다.
이 스프링 MVC 를 사용하기 쉽게 구성한 것이 스프링 부트다. 근데 사실 스프링 MVC 안에 모델에 관련된 부분이 없다.
이 말은  데이터베이스와 통합되지 않았다는 의미가 아닌 다수의 프레임워크로 구성된 종합적인 프레임워크라는 의미다.
이 안에 데이터베이스 관련 부분이 몇 개나 존재한다. 즉, 스프링 MVC 라는 틀 안에 일부러 데이터베이스 처리 기능을
부여할 이유가 없어진 것이다.

그리고 JAP 라는 기술이 토대로 스프링 MVC 의 모델 관련 부분이 구축돼 있다. 모델에 대해 앞으로도 설명하겠지만
'모두 스프링 부트의 기능이 아니다' 라는 것에 유의하자.

        모델에 필요한 기술

여기서 데이터베이스 관련 기능을 구현하기 위해 사용한 것이 JPA 라는 기술이다.
이것은 구체적으로 객체의 내용을 데이터베이스에 저장하고 필요에 따라 꺼내서 객체를 구축하는 기술이다.


            Controller
                ↓
            ┌   ─   ─   ┐
            │ Model     │
            ├   ─   ─   │
            │ JPA       │
            └   ─   ─   ┘
                ↓
            데이터베이스


이 JPA 를 사용하기 위한 라이브러리 및 프레임워크들이다.

    HSQLDB

HSQLDB (Hyper SQL Database) 는 자바로 만들어진 오픈 소스 데이터베이스 라이브러리다.
MySQL 등의 기존 데이터베이스를 사용해도 되지만, 자바로 만들어져 '애플리케이션 자체 내장' 이라는 이점이 있다.
같은 방식의 라이브러리로 JavaDB(Apache Derby) 등이 있지만, HSQLDB 는 용량이 적고 사용이 쉽다는 장점이 있다.
또한 파일에 저장하는 것은 물론 메모리에 데이터베이스를 저장할 수 있어서 개발 단계의 테스트용 데이터베이스에 적합하다.

    JTA

Java Transaction API(JTA) 는 트랜잭션 처리를 제공한다. JPA 와 JTA 를 조합해서 지속성 처리를 구현하게 된다.

    Spring ORM

스프링 프레임워크에 존재하는 ORM(Object-Relational Mapping) 프레임워크다. ORM 이란 객체와 데이터베이스 테이블을 매핑해
임피던스 불일치(impedance mismatch) 라는 문제를 해결해준다.
(임피던스 불일치란 자바 객체와 데이터베이스의 설계 구조상 차이로 발생하는 문제)

    Spring Aspects/Spring AOP

스프링 프레임워크의 내부 프레임워크다. 이 안에 있는 기능들을 직접 호출해서 사용하는 것이 아니라 데이터베이스를
자유롭게 사용할 수 있게 백그라운드에서 동작히는 구조라고 생각하면 된다.

이런 라이브러리나 프레임워크를 통합적으로 사용해서 스프링 MVC 의 모델을 작성한다.
이렇게 말하면 준비 해야할 것이 많을 것 같지만 걱정하지 않아도 된다.

스프링 부트에선 위의 라이브러리 및 데이터베이스 부분인 HSQLDB 를 제외한 모든 것을 'Spring Boot Starter Data JPA' 라는
라이브러리를 사용해서 통합적으로 사용할 수 있다. Spring Boot Starter Data JPA 는 각종 라이브러리를 조합해서 간단히
데이터베이스 접속을 구현하게 한 기능이다.
따라서 실제 개발 시에는 '데이터베이스' 와 'Spring Boot Starter Data JPA' 만 있으면 된다.

    pom.xml 변경하기

앞서 말한 라이브러리에 대한 다운로드을 하기 위해 pom.xml 을 수정해보자.
메이븐을 사용한다면 mvc spring-boot:run 으로 애플리케이션을 실행하면 라이브러리가 다운로드 된다.

        엔터티에 대해

이제 모델이 되는 자바 클래스를 작성하자.
JPA 를 이용하는 경우, 데이터베이스의 데이터에 해당하는 부분을 엔터티라고 하는 클래스로 정의한다.
데이터베이스에선 데이터 내에 테이블을 정의하고 거기에 레코드 형태로 데이터를 저장하는 것이 일반적이지만,
엔터티는 하나하나의 레코드를 자바 객체로 저장하는 것이라고 보면 된다. 테이블에서 필요한 레코드를 추가하는 경우도
엔터티 클래스의 인스턴스를 만들어서 그것을 영구화하는 처리를 하면 JPA 에 의해 해당 객체의 내용을 레코드로서 테이블에
저장할 수 있다.
엔터티 클래스는 어떤식으로 처리할 까 기본형을 정리하면 다음과 같다.


    @Entity
    public class 클래스명 {
        private 필드 정의;
        ... 필요한 만큼 필드 정의 ...
    }


엔터티 클래스는 매우 단순한 구조로 되어 있다. 이것을 일반적인 POJO (Plain Old Java Object,
아무 상속 관계 또는 의존 관계가 없는 자바 객체) 라고 한다. 한가지만 주의하면 된다.
클래스 정의 시에 앞에 @Entity 라는 어노테이션을 붙여야 한다는 것이다.
엔터티에는 저장할 값을 필드로 정의한다. 보통은 private 필드로 정의하고 각각에 접근자가 되는 메소드를 정의한다.
이것이 전부 별도 설정이 필요 없다.

        MyData 클래스 작성

실제로 간단한 엔터티 클래스를 작성해보자. 여기서는 다음과 같은 항목을 값으로 저장하는 클래스를 생각해보자.


    ID      메인 키로 사용되는 ID 번호(long)
    name    이름(String값)
    mail    메일주소(String값)
    age     연령(int값)
    memo    메모(String값)


아주 간단한 개인 정보 관리 테이블을 생각하면 된다. 이것을 보관할 MyData 라는 클래스를 작성해보자.
컨트롤러와 같은 위치에 MyData.java 라는 이름의 코드 파일을 만든다.

        엔터티 클래스의 어노테이션에 대해

클래스 자체는 단순하지만 어노테이션을 사용해서 클래스나 필드 관련 세부 정보들을 지정하고 있다.
여기서 사용한 어노테이션들을 정리하면 다음과 같다.

    @Entity

이것은 엔터티 클래스라는 것을 나타내는 아노테이션이다. 엔터티 클래스에선 반드시 기술해야 한다.

    @Table(name="mydata")

엔터티 클래스에 할당되는 테이블을 지정한다. name 으로 테이블명을 설정하면 된다. 사실은 이 항목을 생략해도
상관없으며 그때는 클래스명이 테이블명으로 사용된다.

    @Id

메인 키를 지정한다. 엔터티 클래스를 정의할 때는 반드시 설정해야 한다.

    @GeneratedValue(strategy = GenerationType.AUTO)

메인 키의 필드에 설정돼 있다. 이것은 값을 자동 생성하는 역할을 한다. strategy 에 생성 방법을 지정한다.
GenerationType 이라는 열거형 값을 설정하며 여기서는 AUTO를 사용하고 있다. 이것은 자동으로 값을 할당하는 방식이다.

    @Column

해당 필드에 할당한 컬럼(열) 을 지정하며 생략할 수 있다. 생략한 경우에는 필드명이 그대로 컬럼명으로 사용된다.
이 어노테이션에는 필드에 관련된 몇 가지 인수가 존재한다. 여기서는 다음 인수를 사용하고 있다.


    name        컬럼명을 지정한다(여기선 생략함)
    length      최대 길이(String 에선 문자 수)를 지정한다.
    nullable    null(미입력)의 허용 여부를 지정한다.


보면 알겠지만 @Entity 나 @Id 는 필수 항목이며 @Table 과 @Column 은 생략 가능 항목으로, 기존 테이블에 엔터티를 할당할 때
사용하는 것으로 생각하면 된다. 여기선 기본 어노테이션으로 사용하고 있지만 생략해도 상관없다.
일단 엔터티 부분이 완성됐다. 계속해서 이것을 사용하기 위한 기능을 만들겠다. 그렇다고 해서
컨트롤러에 엔터티를 위한 처리를 작성할 수 있는 것은 아니다. 스프링 부트에선 데이터베이스 접속을 위한 클래스를
먼저 준비해야 한다.

        리포지터리에 대해

엔터티는 테이블에 저장된 데이터를 자바 내에서 객체로 사용할 수 있게 하는 클래스지만, 이것만으로 데이터베이스 연결이
완성되는 것은 아니다. 별도로 데이터베이스 접속에 필요한 설정을 해야 한다.
이를 위해서는 다양한 방법이 존재하지만, 스프링 부트의 장점을 십분 경험할 수 있도록 리포지터리 방법을 설명하겠다.
그리고 뒤에서는 데이터베이스 접속의 기본이 되는 EntityManager 라는 클래스를 사용해서 고도의 검색 기능 등을 구현한다.

리포지터리는 데이터베이스 접속을 위한 기본적인 수단을 제공한다. 이것은 보통 인터페이스로 설정한다.
'그렇다고 인터페이스를 구현한 클래스를 정의하고 그 안에 데이터베이스 접속 처리를 작성한다' 고 생각할 수 있지만 아니다.
클래스를 구현하지 않고도 별도의 처리도 작성하지 않는다.

리포지터리는 범용적인 데이터베이스 접속 처리를 자동으로 생성한다. 이 때문에 코드 작성 없이 데이터베이스 접속 처리를 할
수 있다. 설명은 했지만 '코드를 작성하지 않고도 데이터베이스를 접속' 할 수 있다.
이것을 설명보다 직접 사용을 해보자.

        리포지터리용 패키지 준비

리포지터리 클래스를 배치하기 위한 패키지를 준비한다.
컨트롤러와 동일한 위치에 repositories 라는 폴더를 만들자.

        리포지터리 클래스 MyDataRepository 작성

다음은 리포지터리 클래스를 작성해야 한다. 클래스라고 하지만 사실은 인터페이스를 만드는 것이다.
'MyDataRepository' 라는 이름으로 인터페이스를 만들자.

    MyDataRepository.java

매우 단순한 구조다. 인터페이스 자체는 JpaRepository<MyData, Long> 클래스를 상속하고 있다.
이 JpaRepository 라는 클래스(정확히 인터페이스)는 새로운 리포지터리를 생성하기 위한 토대가 된다.
모든 리포지터리는 JpaRepository 를 상속해서 작성된다. 그리고 인터페이스 안에는 아직 아무 메소드가 정의돼 있지 않다.
비어있는 상태지만 일단 이 상태로 둔다.

        리포지터리 사용하기

실제로 리포지터리를 사용해보자. 먼저 컨트롤러부터 작성하겠다.

    HeloController01.java

        리포지터리의 메소드 확인

작성한 컨트롤러에서 엔터티의 목록 표시 부분 및 저장 부분이 어떻게 돼있는지 보자.

    리포지터리 연동

가장 먼저 @Autowired 어노테이션을 사용해서 MyDataRepository 인스턴스를 필드와 연동하고 있다.


    @Autowired
    MyDataRepository repository;


이 @Autowired 라는 어노테이션은 애플리케이션에 있는 Bean 객체(스프링 MVC에 의해 자동으로 인스턴스가 생성돼서
애플리케이션 내에서 사용할 수 있게 된것)와 연동하기 위한 것이다. 이것을 사용해서 MyDataRepository의 인스턴스가 자동으로
repository 필드로 설정된다. MyDataRepository는 인터페이스인데? 라고 생각할 수 있다.
하지만 인스턴스가 제대로 설정되는 것을 알 수 있다. 스프링 MVC 에 의해, 인터페이스에 필요한 처리를 탑재한 무명 클래스가
만들어지면 이 클래스의 인스턴스가 생성되는 것이다.

    Bean 이 등록되기까지의 흐름

스프링 프레임워크에선 미리 클래스를 Bean 으로 등록해두고 해당 Bean 을 인스턴스 필드에 자동으로 연동해서 사용할 수
있게 만든다. 정리하자면 리포지터리의 경우,


    1. 애플리케이션 실행 시에 @Repository 가 붙은 인터페이스를 검색해서 자동으로 클래스를 만들고, 해당 인스턴스를
        애플리케이션에 Bean 으로 등록한다.

    2. 컨트롤러 등의 클래스가 로드될 때 @Autowired 가 설정된 필드가 있으면 등록 완료된 Bean 에서 동일 클래스를
        검색해서 자동으로 해당 필드에 할당된다.


이런 구조로 필드에 필요한 리포지터리의 인스턴스가 할당돼서 사용할 수 있게 된다.
'왜 스프링 프레임워크는 특정 클래스를 자동으로 Bean 으로 등록하는가, 그리고 어떻게 등록할 클래스를 식별하는가'
라는 의문을 가질 수 있는데, 사실 스프링 프레임워크가 제공하는 각종 어노테이션에 의해 '이 클래스의 인스턴스를
Bean 으로 등록한다' 는 것을 인식하고 있다.
따라서 우리가 해야할 작업은 '@Repository 를 지정한 인터페이스를 준비, @Autowired 를 지정한 리포지터리 인터페이스의
필드 준비' 가 전부다. 이외의 코드 작성 등이 전혀 필요 없다.
스프링 부트의 기반이 되는 스프링 프레임워크의 모든 기능은 '필요한 기능을 Bean 으로 설정하고 그것을 자동으로 필드
등에 연동한다' 는 방식으로 만들어져있다. '얼마나 Bean 을 잘 사용하는가' 가 스프링 부트를 이해하는데 있어 매우 중요하다.

    findAll 메소드에 대해

여기선 repository 의 'findAll' 메소드를 사용하고 있다. 다음 부분이다.


    Iterable<MyData> list = repository.findAll();


MyDataRepository 에는 findAll 같은 메소드가 정의돼 있지 않다. 이것은 부모 클래스인 JpaRepository 가
가지고 있는 메소드다. 이를 통해 모든 엔터티가 자동으로 추출되는 것이다.
'JpaRepository 에 findAll' 메소드가 있다는 것은 알았지만 이 JpaRepository 에선 MyData 라는 클래스가 엔터티라는 것을
어떻게 알까?


    public interface MyDataRepository extends JpaRepository<MyData, Long> { ... }


제네릭으로 MyData 와 Long 을 지정하고 있다. 여기서 대상이 되는 엔터티 클래스가 MyData 이고 메인 키가 Long 형의 값이라는
것을 지정하고 있다.

    템플릿 준비

화면에 데이터를 표시하기 위한 템플릿을 작성해보자.

    index01.html

접속하면 저장돼 있는 MyData가 회색 사각 틀 안에 표시된다. 아직 데이터가 없어서 빈 배열 [] 라고 표시된다.